import os
import sys

from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain_huggingface.llms import HuggingFacePipeline
from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline

from transf_class_extractor import extract_class_core

def save_script(generated_code: str, end_of_gen: str):
    """
    Save the Python code generated by the LLM to a file.

    Args:
        generated_code (str): The code text generated by the LLM.
        end_of_gen (str): The end of the generated code.
    """
    print("Taking answer.")
    start_index = generated_code.find("Python Code:")

    python_code = generated_code[start_index + len("Python Code:"):].strip()

    end_index = python_code.find(end_of_gen)
    python_code = python_code[:end_index].strip()

    print(f"Saving result into file: solution.py")
    f = open("solution.py", "w")
    f.write(python_code)
    f.close()


def llm_request(task_description: str, model_id: str, origin_csv_file: str, final_csv_file: str):
    """
    This method make a request to the LLM and generate script that apply changes to

    Args:
        task_description (str): Description of manipulations over dataframe
        model_id (str): The name of the model from HuggingFace
        origin_csv_file (str): Path to the file with original dataset
        final_csv_file (str): Path where new dataset will be saved
    """
    # Define model ID and load tokenizer
    tokenizer = AutoTokenizer.from_pretrained(model_id)

    # Load model with configuration
    model = AutoModelForCausalLM.from_pretrained(
        model_id,
        device_map="auto",
        torch_dtype="auto"
    )

    # Create a text-generation pipeline
    pipe = pipeline(
        "text-generation",
        model=model,
        tokenizer=tokenizer,
        max_new_tokens=500,
        top_k=20,
        temperature=0.3
    )

    # Wrap the HuggingFace pipeline with LangChain
    llm = HuggingFacePipeline(pipeline=pipe)

    print("HuggingFace pipeline generated.")

    end_of_gen = "END_OF_IMPLEMENTATION"

    code_template = """
    Lower will be defined class for manipulation over dataframe object, template class for result format, and task. 
    You should use this defined class for solving task of manipulation over dataframe, you can use only methods of class for doing it.
    Code template provide python code, where should be replaced comment to sequence of class methods.
    And task, that should be solved with usage of predefined class and output should be in form of template code.
    After the main that call function main() must be added string "END_OF_IMPLEMENTATION" for identification of generation end.

    Class:
    {class_code}

    Code template:
    {code_template}

    Task:
    {task_description}

    Python Code:
    """

    # Set up the prompt templates
    code_prompt = PromptTemplate(template=code_template,
                                 input_variables=["class_code", "code_template", "task_description"])

    # Create chains for generating Python code using LangChain
    code_chain = LLMChain(llm=llm, prompt=code_prompt)

    print("Taking class core.")
    class_code = extract_class_core("DataFrameTransformer.py")

    print("Taking solution template code.")
    f = open("solution_template.py")
    code_template = f.read()
    f.close()

    print("Starting generate answer.")
    generated_code = code_chain.run(class_code=class_code,
                                    code_template=code_template,
                                    task_description=task_description,
                                    stop=["END_OF_IMPLEMENTATION"])

    save_script(generated_code, end_of_gen)

    print(f"Execute generated file.")
    os.system(f"python solution.py {origin_csv_file} {final_csv_file}")

def main():
    """
    This is the main function that runs when this file is executed.

    There defines model, that will be used for code generation.
    """
    argv = sys.argv

    if not (2 <= len(argv) <= 5):
        print("Error: Incorrect number of arguments! There should be between 1 and 4 arguments.")
        return None

    # Assign values dynamically with default initialization
    task_description = argv[1]
    origin_csv_file = argv[2] if len(argv) > 3 else "../dataframes/Housing.csv"
    final_csv_file = argv[3] if len(argv) > 4 else "../dataframes/Housing_Modified.csv"
    model_id = argv[4] if len(argv) > 2 else "codellama/CodeLlama-7b-hf"

    llm_request(task_description, model_id, origin_csv_file, final_csv_file)

if __name__ == '__main__':
    main()
